import threading
from socket import *
from customtkinter import *


class MainWindow(CTk):
    def __init__(self):
        super().__init__()
        self.geometry("1200x700")
        self.title("LOGIKATALK")

        # Боковое меню
        self.frame = CTkFrame(self, width=200, height=700)
        self.frame.pack_propagate(False)
        self.frame.configure(width=0)
        self.frame.place(x=0, y=0)
        self.is_show_menu = False
        self.speed_animate_menu = 5
        self.animation_running = False  # Флаг для контроля анимации

        # Элементы меню (создаются один раз в __init__)
        self.nickname_label = CTkLabel(self.frame, text="Ваш нікнейм")
        self.nickname_label.pack(pady=30)

        self.nickname_entry = CTkEntry(self.frame)
        self.nickname_entry.pack(pady=10)

        self.apply_nickname_btn = CTkButton(self.frame, text="Застосувати", command=self.apply_nickname)
        self.apply_nickname_btn.pack(pady=10)

        self.label_theme = CTkOptionMenu(self.frame, values=["Темна", "Світла"], command=self.change_theme)
        self.label_theme.pack(pady=20)

        # Кнопка меню
        self.btn = CTkButton(self, text="➡", command=self.toggle_show_menu, width=30, height=30)
        self.btn.place(x=5, y=5)

        # Область чата
        self.chat_text = CTkTextbox(self, state="disabled", width=1100, height=600)
        self.chat_text.place(x=50, y=50)

        # Поле ввода
        self.message_input = CTkEntry(self, placeholder_text="Введіть повідомлення...", width=1050, height=30)
        self.message_input.place(x=50, y=660)
        self.message_input.bind("<Return>", lambda e: self.send_message())

        # Кнопка отправки
        self.send_button = CTkButton(self, text="➡", width=40, height=30, command=self.send_message)
        self.send_button.place(x=1110, y=660)

        # Подключение к серверу
        self.username = "User"
        self.sock = None
        try:
            self.sock = socket(AF_INET, SOCK_STREAM)
            self.sock.connect(("localhost", 8080))
            hello = f"TEXT@{self.username}@[SYSTEM] {self.username} приєднався до чату!\n"
            self.sock.send(hello.encode("utf-8"))
            threading.Thread(target=self.recv_message, daemon=True).start()
            self.add_message("[SYSTEM] Підключено до сервера!", is_system=True)
        except Exception as e:
            self.add_message(f"[ERROR] Не вдалося підключитися: {e}", is_system=True)

        self.adaptive_ui()

    def apply_nickname(self):
        """Применяет новый никнейм"""
        new_name = self.nickname_entry.get().strip()
        if new_name:
            self.username = new_name
            self.add_message(f"[SYSTEM] Нікнейм змінено на: {new_name}", is_system=True)

    def toggle_show_menu(self):
        """Переключает состояние меню"""
        # Если анимация уже запущена, не запускаем новую
        if self.animation_running:
            return

        self.is_show_menu = not self.is_show_menu

        if self.is_show_menu:
            self.btn.configure(text="⬅")
        else:
            self.btn.configure(text="➡")

        self.animation_running = True
        self.show_menu()

    def show_menu(self):
        """Анимация открытия/закрытия меню"""
        current_width = self.frame.winfo_width()

        if self.is_show_menu:
            # Открываем до 200px
            new_width = min(current_width + self.speed_animate_menu, 200)
        else:
            # Закрываем до 0px
            new_width = max(current_width - self.speed_animate_menu, 0)

        self.frame.configure(width=new_width)

        # Продолжаем анимацию если не достигли цели
        if (self.is_show_menu and new_width < 200) or (not self.is_show_menu and new_width > 0):
            self.after(10, self.show_menu)
        else:
            # Анимация завершена
            self.animation_running = False

    def change_theme(self, value):
        """Меняет тему приложения"""
        if value == "Темна":
            set_appearance_mode("dark")
        else:
            set_appearance_mode("light")

    def adaptive_ui(self):
        """Адаптивное позиционирование элементов"""
        menu_width = self.frame.winfo_width()
        window_width = self.winfo_width()
        window_height = self.winfo_height()

        # Чат
        self.chat_text.place(x=menu_width + 10, y=50)
        chat_width = window_width - menu_width - 20
        chat_height = window_height - 100
        if chat_width > 0 and chat_height > 0:
            self.chat_text.configure(width=chat_width, height=chat_height)

        # Поле ввода
        input_width = window_width - menu_width - 60
        if input_width > 0:
            self.message_input.configure(width=input_width)
        self.message_input.place(x=menu_width + 10, y=window_height - 40)

        # Кнопка отправки
        self.send_button.place(x=window_width - 40, y=window_height - 40)

        self.after(50, self.adaptive_ui)

    def add_message(self, text, is_system=False):
        """Добавляет сообщение в чат"""
        self.chat_text.configure(state="normal")
        if is_system:
            self.chat_text.insert(END, text + "\n", "system")
            self.chat_text.tag_config("system", foreground="gray")
        else:
            self.chat_text.insert(END, text + "\n")
        self.chat_text.see(END)
        self.chat_text.configure(state="disabled")

    def send_message(self):
        """Отправляет сообщение на сервер"""
        message = self.message_input.get().strip()
        if message and self.sock:
            data = f"TEXT@{self.username}@{message}\n"
            try:
                self.sock.sendall(data.encode("utf-8"))
                self.add_message(f"Ви: {message}")
            except Exception as e:
                self.add_message(f"[ERROR] Не вдалося відправити: {e}", is_system=True)
        self.message_input.delete(0, END)

    def recv_message(self):
        """Получает сообщения от сервера"""
        buffer = ""
        while True:
            try:
                chunk = self.sock.recv(4096)
                if not chunk:
                    break
                buffer += chunk.decode("utf-8")

                while "\n" in buffer:
                    line, buffer = buffer.split("\n", 1)
                    self.handle_line(line.strip())
            except Exception as e:
                self.add_message(f"[ERROR] З'єднання втрачено: {e}", is_system=True)
                break

        if self.sock:
            self.sock.close()

    def handle_line(self, line):
        """Обрабатывает полученную строку"""
        if line.startswith("TEXT@"):
            parts = line.split("@", 2)
            if len(parts) == 3:
                username = parts[1]
                message = parts[2]
                self.add_message(f"{username}: {message}")


if __name__ == "__main__":
    win = MainWindow()
    win.mainloop()
